<!DOCTYPE html><html lang="ja"><head><title>cloud flare workerで省エネSSRなBlogを目指す | shinyaigeek.dev</title><meta charset="utf8"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><meta property="og:title" content="cloud flare workerで省エネSSRなBlogを目指す | shinyaigeek.dev"><meta property="og:site_name" content="shinyaigeek.dev"><meta property="og:locale" content="ja_JP"><meta name="description" content="Web が好きなオタクのブログ. 主にweb開発の知見について喋ります"><meta property="og:description" content="Web が好きなオタクのブログ. 主にweb開発の知見について喋ります"><meta property="og:url" content="https://shinyaigeek.dev/ja/post/how-to-make-economic-ssr-with-clourflareworker"><meta name="twitter:site" content="@shinyaigeek"><meta property="og:type" content="website"><meta name="twitter:card" content="summary_large_image"><meta property="og:image" content="https://ja.shinyaigeek.dev/assets/ogimage/ja/how-to-make-economic-ssr-with-clourflareworker.png"><meta name="twitter:image" content="https://ja.shinyaigeek.dev/assets/ogimage/ja/how-to-make-economic-ssr-with-clourflareworker.png"><link rel="icon" type="image/x-icon" href="/assets/static/favicon.ico"><link rel="stylesheet" type="text/css" href="/assets/styles.ada9902fc362b01889c3.css"><link rel="stylesheet" type="text/css" href="/assets/static/a11y-dark.min.css"><link rel="stylesheet" href="https://unpkg.com/github-calendar@latest/dist/github-calendar-responsive.css"><link rel="preload" as="style" href="/assets/static/a11y-dark.min.css"><link rel="preload" as="style" href="/assets/styles.ada9902fc362b01889c3.css"><link rel="preload" as="style" href="https://unpkg.com/github-calendar@latest/dist/github-calendar-responsive.css"><link rel="preload" as="image" href="/assets/static/icon_transparent_header.png"><link rel="alternate" type="application/rss+xml" title="shinyaigeek.dev" href="/rss.xml"></head><body><div id="_app"><div class="fmapAu0fpx364Dzl_9z0"><div class="J2e3WZniL57BvLtita5T"><div class="kVHiWHyN1gv5Y41SpACy"><a href="/" class="link2Home"><div><img src="/assets/static/icon_transparent_header.png" alt="icon" class="vwQ8HQPKPoICc2atrDju" width="36px" height="36px">shinyaigeek.dev</div></a></div><div class="hOkVSJvM823tjX0FjgO_"><div class="FpNMxf5Gx0pwkDBdeqif"><details><summary> <span role="img" aria-label="language"><g-emoji fallback-src="/assets/static/earth_africa.png" alias="earth">🌍</g-emoji></span> 日本語</summary><div class="ZAVxrSvsXSeI9pV9Rbax"><a href="http://ja.shinyaigeek.dev/post/how-to-make-economic-ssr-with-clourflareworker" class="aYFqAG93sRJ7BJMCPjsa undefined"><span role="img" aria-label="country"><g-emoji fallback-src="/assets/static/jp.png" alias="Japan">🇯🇵</g-emoji></span>日本語</a><a href="https://en.shinyaigeek.dev/post/how-to-make-economic-ssr-with-clourflareworker" class="aYFqAG93sRJ7BJMCPjsa"><span role="img" aria-label="country"><span><g-emoji fallback-src="/assets/static/us.png" alias="America">🇺🇸</g-emoji><g-emoji fallback-src="/assets/static/gb.png" alias="United States">🇬🇧</g-emoji></span></span>English</a></div></details></div><div class="FpNMxf5Gx0pwkDBdeqif"><a href="/" class="link2Home">Blog</a></div><div class="FpNMxf5Gx0pwkDBdeqif"><a href="/profile" id="link2profile">Profile</a></div><div class="FpNMxf5Gx0pwkDBdeqif"><a href="https://github-activity.shinyaigeek.dev/" id="link2activity">Activity</a></div></div></div><div class="sxaQUUuymSmhNwqAMaks"><div><details class="h0AHqg9AmVXjXCnYqFqc"><summary class="post--anchor__title" id="post--anchor__title">目次</summary><a href="#2__0">はじめに</a><a href="#2__1">Cloud flareってなんぞ</a><a href="#2__2">cloudflare workerって何？</a><a href="#2__3">cloudflare workerを動かしてみる</a><a href="#2__4">Routing</a><a href="#2__5">Cache API</a><a href="#2__6">やっていき</a></details><div class="Y8c8TlU3k_Y72ndSGmnk"><h1>cloud flare workerで省エネSSRなBlogを目指す</h1><div>2020/04/13</div><div class="BYkaTwWlH4C2pP1hi2JY"><div>Blog</div><div>Programming</div><div>Web</div></div></div><div class="L6tHhpo3uw534DnsakEH"><h2 id="2__0">はじめに</h2>
<p>世は技術ブログ大時代. みんなはてなブログか<a href="https://jamstack.org/">JAMstack</a>にその身を委ねていた. お手軽さを求めるならはてなブログ, あるいはそこにカスタマイズ性やスピードを求めてHeadlessCMSにコンテンツを追加して動的に静的サイトを更新していくJAMstackな構成を目指した. 実際今の時代, GatsbyjsなりNextjsでもcontentfulなどを組み込んだJAMstackのテンプレートがあるので, HeadlessCMSからAPIを取得して環境変数として設定して, 適切にCI/CDを組んであげればもうJAMstackによる高速でお手軽な技術ブログが完成します. すごい時代だ.でもそんな中, あえてSSRを用いた動的な構成にロマンを感じて動的なブログを構築しようとした男がいました, いや僕なんですけど. cloud runでNode.jsの上にexpressサーバーを生やして, そこでJSXをreact-domを通してhtmlにしています.</p>
<p>しかし一回のアクセスごとにexpressが立ち上がると時間がかかる(特にTTFB), そもそも従量課金制なのでアクセスのたびにサーバーを立ち上げるのでなく, 出来るだけキャッシュを効かせたい. 特にこの場合本質となるブログ記事はCMS上にあるのでそこを参照したい.</p>
<p>というのを叶えたく, edge-sideでスクリプトを動かしてキャッシュを動的に管理して更なる最適化を目指す, という取り組みをしてみます.</p>
<h2 id="2__1">Cloud flareってなんぞ</h2>
<p>一言で言い難いのですが, めちゃ簡単に使えるリバースプロキシを利用したCDNサービスとしておきましょう. サービスとしてはそこだけではないのですが,</p>
<ul>
<li>この記事ではCDN, リバースプロキシとして利用している</li>
<li>説明がしんどい, 記事の本質でない</li>
</ul>
<p>というのがありますので詳細は省かせてもらいます. 詳しく知りたい方は公式のwebページを参照してください.</p>
<p>サーバーから配信される内容をCDNにキャッシュしておくことで, サーバーの負担を減らす, 帯域を減らしてパフォーマンス向上が図れたりします. コンテンツの配信元と, クライエントとなるブラウザの物理的距離が小さくなることも魅力です. え, そんなの影響する？と思うかもしれませんが, 適当に海外のカフェとかの個人webサイトとかを覗いてもらえば物理的距離の影響が見えると思います, CDNはこれを解消する一助になりますね.</p>
<p>ちなみにですがJAMstack構成でブログ作っている人は, cloud flareにそのweb serverを登録するだけでその恩恵がかなり受けられます. 個人のweb siteなら無料で利用できますし, かなりお手軽に登録できるのでやってみてください.</p>
<h2 id="2__2">cloudflare workerって何？</h2>
<p>そもそもCloudflare workerとはなんなんでしょう？ ついさっき</p>
<blockquote>
<p>ちなみにですがJAMstack構成でブログ作っている人は, Cloud flareにそのweb serverを登録するだけでその恩恵がかなり受けられます.</p>
</blockquote>
<p>といっていますが, 実はこれだけで僕のこのブログの動的な構成でも全然恩恵を受けることができます.
そもそもedge-sideを介すことでどんなことがおきてるかというと,</p>
<p><img src="//images.ctfassets.net/6ib5avrqb1b0/3Me2xX0XcsXmpJzhWo0hCM/31f64cdc0e36942bad76d0b23ac7acf2/IMG_82073C6538F5-1.jpeg" alt="how-works-cdn"></p>
<p>こんな感じで,</p>
<ol>
<li>clientからReqestが飛ぶ</li>
<li>Edge-serverでそれを受け取りキャッシュを見る</li>
<li>そのキャッシュされた内容をクライエントに返していいかどうかserverに確認しにいく</li>
<li>OKと返ってくる</li>
<li>キャッシュされた内容をクライエントに返す</li>
</ol>
<p>みたいなことがおきています(といってもこの流れは過度に一般化されていて, もちろん状況によって分岐は生じますが)</p>
<p>でもこれだとclientからアクセスが飛ぶたびにCloudRunが立ち上がってしまいます. いちいちサーバーを建ててhtmlを生成しても時間が勿体無いですし, 何よりお金がかかります.</p>
<p>そもそも本質となるブログ記事はCMS上にあるので, キャッシュされているコンテンツをそのまま返していいか判定したければ, そもそもCMSだけ覗けば十分なはずです.</p>
<p>これを可能にするのがcloudflareでservice worker的な, scriptを動かしてキャッシュを制御するcloud flare workerです.</p>
<p>因みにJSだけでなくRustやCも動かす事が出来ます.</p>
<h2 id="2__3">cloudflare workerを動かしてみる</h2>
<p>といってもやることは至極単純です.</p>
<ol>
<li>CMSから記事の更新状況をfetchしてくる</li>
<li>その結果をみてキャッシュされているコンテンツが最新のものか判断する</li>
<li>最新のものだったらキャッシュされているコンテンツをクライエントに返す, 最新のものでなかったらCMS上のデータをもとにhtmlを生成してクライエントに返す, そしてそのhtmlとcmsから取ってきたデータをキャッシュしておく</li>
</ol>
<p>という感じです.</p>
<p>まずcloudflare workerを編集するために<strong>wrangler</strong>を導入しましょう.</p>
<pre><code class="hljs language-shell">npm i @cloudflare/wrangler -g
</code></pre>
<p>で<strong>wrangler</strong>をグローバルインストールします.</p>
<p>で次にworkerのcodeを置いておきたいディレクトリで</p>
<pre><code class="hljs language-shell">wrangler generate my-router-app
</code></pre>
<p>を実行してセットアップします.</p>
<p>生成されるpackage.jsonをみてもらえれば分かる通り, mainとなるcodeは<strong>index.js</strong>ですので, そこのファイルが書き換える対象です.</p>
<p>そこでは<strong>fetch</strong>に対するイベントリスナーとそのハンドラが生えています.
なのでがっつり触るべきはハンドラですね.<br>
因みに初期のものから触っていなければ,</p>
<pre><code class="hljs language-javascript">event.<span class="hljs-title function_">respondWith</span>(<span class="hljs-title function_">handleRequest</span>(event))
</code></pre>
<p>としていますので, ハンドラとなるhandleRequestのなかで</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">return</span> <span class="hljs-title class_">Response</span>
</code></pre>
<p>という体になっていれば大丈夫です.</p>
<p>因みにですが<strong>wrangler</strong>を使っていれば</p>
<pre><code class="hljs language-shell">wrangler publish // publishされる

wrangler preview --watch // dev-serverを建てる(HRM付き)
</code></pre>
<p>という感じです.</p>
<h2 id="2__4">Routing</h2>
<p>まずこの場合(僕のブログ), 動的なスクリプトを効かせたいのは<strong>https://~~~/index.html</strong>だけです. このように, このメソッドだったらこういうハンドラで, このpathだったらこのハンドラでというのも勿論あるでしょう.
そのためにRoutingは不可欠ですね.</p>
<p>といってもcloudflare workerの場合Routingはかなり原始的にする必要があり,</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(event.<span class="hljs-property">request</span>.<span class="hljs-property">url</span>);
</code></pre>
<p>でurlを取れるので, <strong>url.method</strong>でメソッドを取って, <strong>url.pathname</strong>でpathを取って, switch文で頑張りましょう.</p>
<p>e.g.</p>
<pre><code class="hljs language-javascript">
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleRequest</span> = (<span class="hljs-params">event</span>) => {
  <span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(event.<span class="hljs-property">request</span>.<span class="hljs-property">url</span>)
  
  <span class="hljs-keyword">switch</span>(url.<span class="hljs-property">method</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"GET"</span>: {
      <span class="hljs-comment">// handleGETMethod</span>
      <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">case</span> <span class="hljs-string">"POST"</span>: {
      <span class="hljs-comment">// handlePOSTMethod</span>
      <span class="hljs-keyword">break</span>
    }
    <span class="hljs-attr">default</span>: {
      <span class="hljs-comment">// asdf</span>
      <span class="hljs-keyword">break</span>
    }
  }
}

</code></pre>
<h2 id="2__5">Cache API</h2>
<p><strong>Cache API</strong> を用いてキャッシュを制御します. 仰々しく聞こえますが, そんなややこしいことをする感じでもありません. そもそも利用可能なCacheに生えているメソッドはput, match, deleteだけです.
その内容も直感的に分かる通り</p>
<ul>
<li>putでキャッシュする</li>
<li>deleteで消す</li>
<li>matchでキャッシュを探す</li>
</ul>
<p>という感じです.
引数も単純で例えばputは<strong>put(Request, Response)<strong>です. 因みにworker文脈でのRequestはstring値も受け取れます. 察しのいい人は気付いちゃうと思いますがなんか</strong>Request</strong>をkeyと見なせば<strong>Map</strong>っぽさが出てきますね.
matchについては<strong>match(Request, options)<strong>で該当Requestに対してキャッシュがあればそのキャッシュの</strong>Response</strong>を, なければ<strong>undefined</strong>を返します. optionについては割愛.
deleteについては**delete(Request, options)**で該当Requestに対してキャッシュがあればそのキャッシュを削除するという感じです.</p>
<p>また<strong>put</strong>や<strong>delete</strong>を利用する時は, <strong>event.waitUntil</strong>で, putやdeleteが完了する前にサーバーが落ちないように制御しましょう. サーバーレス感があります
.
因みにCache APIのdocsはここにあります<a href="https://developers.cloudflare.com/workers/reference/apis/cache/">https://developers.cloudflare.com/workers/reference/apis/cache/</a>.</p>
<p>またPreview modeについてはCacheAPIは未実装でまだ使えないっぽいので, 何度cache.putしてもキャッシュされていないという事態が起こります.注意してください(僕はここがわからず3０分くらい溶かしました)</p>
<p>因みに以下のtemplateではCache APIが実際にどう使われてるかのexampleがみれます. <a href="https://developers.cloudflare.com/workers/templates/pages/cache_api/">https://developers.cloudflare.com/workers/templates/pages/cache_api/</a></p>
<h2 id="2__6">やっていき</h2>
<p>さあ材料はだいたい揃ったのでやっていきましょう.
といってもやることは本当に単純です.</p>
<p>まず僕の場合, HeadlessCMSのcontentfulを使ってブログ記事を管理しています.
contentfulだと以下のAPIが生えているので, <a href="https://www.contentful.com/developers/docs/references/content-delivery-api/#/introduction/authentication">https://www.contentful.com/developers/docs/references/content-delivery-api/#/introduction/authentication</a>, あとはtokenを取って<strong>fetch</strong>でブログコンテンツを参照する準備をします.</p>
<p>以下はかなり事例レベルでfittingされてる話なのであまり参考にならないと思いますが, 実装としては</p>
<pre><code class="hljs language-javascript">
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleRequest</span> = (<span class="hljs-params">event</span>) => {
  
  <span class="hljs-keyword">const</span> cache = caches.<span class="hljs-property">default</span>;

  <span class="hljs-keyword">switch</span>(url.<span class="hljs-property">pathname</span>){
    <span class="hljs-keyword">case</span> <span class="hljs-string">"/"</span>: {
      <span class="hljs-comment">// 基本/index.htmlのみ動的にキャッシュを制御する, それ以外は適当に普通にキャッシュしとけばOK</span>
    
      <span class="hljs-comment">// CMS上にある最新のコンテンツのための一覧を得る</span>
      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://~~~~~~~contentfulのAPI~~~~~/"</span>);
    
      <span class="hljs-keyword">const</span> cachedRes = <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">match</span>(<span class="hljs-string">"jsonのkey"</span>, options);
      
      <span class="hljs-keyword">const</span> curJson = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();
      <span class="hljs-keyword">if</span>(cachedRes){
        <span class="hljs-keyword">const</span> cachedJson = cachedRes.<span class="hljs-title function_">json</span>();
        
        <span class="hljs-comment">// 手元にあるjsonによる, 過去取得してキャッシュしたコンテンツにまつわる一覧のデータを, CMS上にある最新のそれとが一致する時</span>
        <span class="hljs-keyword">if</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(cachedJson) === <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(curJson)) {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">match</span>(<span class="hljs-string">"htmlのkey"</span>);
      }<span class="hljs-keyword">else</span>{
        <span class="hljs-comment">// この時はキャッシュされているものが古い</span>
        
        e<span class="hljs-comment">// 最新のコンテンツにまつわるjsonをキャッシュする</span>
        vent.<span class="hljs-title function_">waitUntil</span>(cache.<span class="hljs-title function_">put</span>(<span class="hljs-string">"jsonのkey"</span>, cachedRes.<span class="hljs-title function_">clone</span>()));
        
      }  <span class="hljs-comment">// 最新のコンテンツにまつわるjsonをサーバーに投げてhtmlを生成してもらう</span>
        <span class="hljs-keyword">const</span> curHTMLRes = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"~~~serverのurl, この場合cloud run~~~"</span>, {
          <span class="hljs-attr">method</span>: <span class="hljs-string">"PUT"</span>,
          <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
            <span class="hljs-attr">item</span>: curJson
          })
        })
        
        event.<span class="hljs-title function_">waitUntil</span>(cache.<span class="hljs-title function_">put</span>(<span class="hljs-string">"htmlのkey"</span>, curHTMLRes.<span class="hljs-title function_">clone</span>()));
        <span class="hljs-keyword">return</span> curHTMLRes;
      
    
    }
    <span class="hljs-attr">default</span>: {
      <span class="hljs-keyword">break</span>
    }
  }
}
</code></pre>
<p>みたいな感じです.</p>
<p>正直上のコードを見たところで得られるものは少なく, 参考にもならないと思いますがcloudflare workerを用いてCacheを動的に最適化するということがそこまで難解なことでもなく, それ自体は単純で見慣れたものであるというのは伝わったかと思います.</p>
<p>完全に余談ですが, 僕的にはserverにhtmlを生成してもらうためだけにRequest投げるのは勿体無いんじゃないかなって思っていて, それをなんとかedge-sideでできないかなと考えています.<br>
wrangler自体はwebpackでbundleさせることができるので, 理論上react-dom/serverくらいなら動くんじゃないかなとは思っています.
今は忙しいのでやらないですが, 気が向いたら実験しては見ます...</p>
<p>因みにですが僕はこの最適化でSpeedIndexが**15%**削減されました.みんなもやってみてね</p></div><div class="XTxSDCE1gmhoF59UaA7g"><div class="mdGYkZO2YHxhxRXU338z"><div class="O6UishUpXe8xGlTrCl8G"><img src="/assets/static/icon_transparent.png" class="J5UgGRYhWe9JWeYlm2bw" alt="monkey-icon" width="270px" height="270px"></div><div class="cab8_7jeBIe5dRHd8ikS"><div class="kEage_DVZV_Stt0z3eAT"><div class="_5U8hWpqU834VUiKxwCpA"><img src="/assets/static/earth.png" alt="earth" width="50px" height="50px"></div></div></div></div><div class="baseprofile"><div class="_pakeuUKwDGIGV1PIDFI">Hi <span role="img" aria-label="wave hand">👋</span> I&#x27;m <span class="zQUgJkaqGKzVRFrvk7mk">Shinobu Hayashi a.k.a Shinyaigeek(しにゃい)</span>.</div><div class="CMC6WyjhCeKfvY5zyyq0"><span data-text="Web Developer" class="v7yavk2O9dr3NZXn186P">Web Developer</span> <g-emoji fallback-src="/assets/static/spider_web.png" alias="spider-web">🕸</g-emoji> / <span data-text="Reliable web Enthusiast" class="v7yavk2O9dr3NZXn186P">Reliable Web Enthusiast</span> <g-emoji fallback-src="/assets/static/fire.png" alias="fire">🔥</g-emoji> </div><div class="gA7tXpIz5V3YPffc9WIr">Faster, Lighter, More accessible, More secure, More productive Web for anyone, anytime , anywhere.</div><div class="v0ZqRqZjlqevKrsWtDTt"><div class="zdvavtYkqc1dXYPR1y0c"><a id="twitter" href="https://twitter.com/Shinyaigeek"><img src="/assets/static/twitter.svg" alt="twitter" width="54px" height="54px"></a></div><div class="zdvavtYkqc1dXYPR1y0c"><a id="github" href="https://github.com/Shinyaigeek"><img src="/assets/static/github.svg" alt="github" width="54px" height="54px"></a></div><div class="zdvavtYkqc1dXYPR1y0c"><a id="linkedin" href="https://www.linkedin.com/in/shinyaigeek/"><img src="/assets/static/linkedin.svg" alt="linkedin" width="54px" height="54px"></a></div></div><div class="l5KzSvykijElHJc7q2c9"><a href="mailto:me@shinyaigeek.dev">Contact Me on Email <g-emoji fallback-src="/assets/static/email.png" alias="email">📧</g-emoji></a></div></div></div></div></div><div class="AJQSVdi_FHylcHDbYLWV">Copyright. 2022 Shinyaigeek</div></div></div></body><script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;0893ac88cf0542af88bfd9b93008b408&quot;, &quot;spa&quot;: true}"></script><script defer="" src="/assets/r.a0d01c88f547277aab5a.js" async=""></script></html>